Since we are reading from a lex file instead of using the built-in lexer for the parser, I handle the file input first. There was a platform independency issue involved in this process. Initially, I splitted the input by '\n'. This seemed to work for all the positive test cases. I posted on Piazza and realized that the lex file could be separated by '\r\n' as well. As a result, I paid special attention to this by checking whether the length of array splitted by '\r\n' is not 1. If not, I split again by '\n'. This seems to be hard-code solution but it works!
Next, I write context free grammars for the parser generator with reference to the syntax of COOL page. Since there still exist some conflicts in the given grammar and precedence specification, I have added the following rules:
1. Add a precedence rule for IN. This is because for let expressions, the expr after the IN token should consume as much tokens as possible. Therefore, I give IN the least precedence and right associativity. 
2. Change the first token of every expr into a Non-terminal. This is for the purpose that we need to get the lineno of an expression for the printing later. I make the first token of an expression into a non-terminal and get the line number there by retrieving the value for yylineno.
For the testing, I started with simple syntax to make sure that my code works for each of them. After that, I wrote a script to compare the results of cool compiler and my code.
To test for errors, I randomly changed or inserted some tokens and compare the error messages with emphasis line numbers. I have also created nested let expressions to make sure that the precedence works for let expressions.

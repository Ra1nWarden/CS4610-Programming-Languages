// Import packages: ./cool_grammar is the parser file generated by jison
var fs = require('fs')
var parser = require('./cool_grammar').parser;

/* IO handling */

// Read the command-line argument file name
var lexfile = process.argv[2]

// Array for tokens
var tokens = []

// Cool keywords
var keywords = ["class", "else", "fi", "if", "in", "inherits", "isvoid", "let", "loop", "pool", "then", "while", "case", "esac", "new", "of", "not", "true", "false"]

// Read in the data from the lex file
var data;
try {
    data = fs.readFileSync(lexfile, {encoding: 'utf8'});
} catch (e) {
    console.log("Invalid file!");
    process.exit(1);
}

// Split the the file into lines
var splitted = data.split("\r\n");
if (splitted.length == 1) {
    // Platform independency
    splitted = data.split("\n");
}

// Running index for looping through the file
var running_index = 0;

// These types have two lines of entries. 
var special_list = ["string", "type", "identifier", "integer"]
    
// Looping through the file and push the token into the array.
while (running_index < splitted.length) {
    if (splitted[running_index] == "" && running_index == splitted.length - 1)
	break;
    var cur_token = {};
    cur_token['lineno'] = Number(splitted[running_index]);
    running_index++;
    if (keywords.indexOf(splitted[running_index]) > -1) {
	cur_token['type'] = 'keyword';
	cur_token['value'] = splitted[running_index];
    }
    else {
	if (special_list.indexOf(splitted[running_index]) > -1) {
	    cur_token['type'] = splitted[running_index];
	    running_index++;
	    cur_token['value'] = splitted[running_index];
	}
	else {
	    cur_token['type'] = 'symbol';
	    cur_token['value'] = splitted[running_index];
	}
    }
    tokens.push(cur_token);
    running_index++;
}

// Index for the lexer
var token_index = 0

/* Overriding the lexer as we are reading the lex file */

parser.lexer = {
    lex: function() {
	// Finish reading the array
	if (token_index == tokens.length) {
	    return "EOF";
	}
	var cl_lex_token = tokens[token_index++];
	var token;
	// Depending on the type of the token, decide whether to read the next line of input
	if (special_list.indexOf(cl_lex_token['type']) > -1) {
	    token = cl_lex_token['type'].toUpperCase();
	    parser.lexer.yytext = cl_lex_token['value'];
	}
	else {
	    token = cl_lex_token['value'].toUpperCase();
	}
	parser.lexer.yylineno = cl_lex_token['lineno'];
	return token;
    },
    setInput: function (str) { }
}

// Parse the tokens into a syntax tree
var final_ast = parser.parse("");

// If things are good, create the file for output
var astfile = lexfile.substring(0, lexfile.length - 3);
astfile = astfile + "ast";
var output = fs.createWriteStream(astfile, {encoding: 'utf8'});

/* Functions for printing */

// Print identifier, this is separated as it is used many times
function printIdentifier(iden, output) {
    output.write(iden['lineno'] + "\n");
    output.write(iden['name'] + "\n");
};

// Print program, this is the starting function call
function printProg(prog, output) {
    output.write(prog.length + "\n");
    prog.forEach(function (clas) {
	printClass(clas, output);
    });
};

// Print a class
function printClass(clas, output) {
    printIdentifier(clas['name'], output);
    if (clas['superclass'] == null) {
	output.write("no_inherits\n");
    }
    else {
	output.write("inherits\n");
	printIdentifier(clas['superclass'], output);
    }
    output.write(clas['features'].length + "\n");
    clas['features'].forEach(function (feature) {
	printFeature(feature, output);
    });
};

// Print a feature
function printFeature(feature, output) {
    output.write(feature['kind'] + "\n");
    printIdentifier(feature['name'], output);
    if (feature['kind'] == "attribute_no_init") {
	printIdentifier(feature['type'], output);
    }
    else if (feature['kind'] == "attribute_init") {
	printIdentifier(feature['type'], output);
	printExp(feature['init'], output);
    }
    else {
	output.write(feature['formals'].length + "\n");
	feature['formals'].forEach(function (form) {
	    printFormal(form, output);
	});
	printIdentifier(feature['type'], output);
	printExp(feature['body'], output);
    }
};

// Print a formal
function printFormal(form, output) {
    printIdentifier(form['name'], output);
    printIdentifier(form['type'], output);
};

// Print an expression
function printExp(expr, output) {
    if (expr['name'] == "bracket") {
	printExp(expr['value'], output);
	return;
    }
    output.write(expr['lineno'] + "\n");
    output.write(expr['name'] + "\n");
    switch (expr['name']) {
	case "assign":
	printIdentifier(expr['var'], output);
	printExp(expr['rhs'], output);
	break;
	case "dynamic_dispatch":
	printExp(expr['e'], output);
	printIdentifier(expr['method'], output);
	output.write(expr['args'].length + "\n");
	expr['args'].forEach(function (arg) {
	    printExp(arg, output);
	});
	break;
	case "static_dispatch":
	printExp(expr['e'], output);
	printIdentifier(expr['type'], output);
	printIdentifier(expr['method'], output);
	output.write(expr['args'].length + "\n");
	expr['args'].forEach(function (arg) {
	    printExp(arg, output);
	});
	break;
	case "self_dispatch":
	printIdentifier(expr['method'], output);
	output.write(expr['args'].length + "\n");
	expr['args'].forEach(function (arg) {
	    printExp(arg, output);
	});
	break;
	case "if":
	printExp(expr['predicate'], output);
	printExp(expr['then'], output);
	printExp(expr['else'], output);
	break;
	case "while":
	printExp(expr['predicate'], output);
	printExp(expr['body'], output);
	break;
	case "block":
	output.write(expr['body'].length + "\n");
	expr['body'].forEach(function (item) {
	    printExp(item, output);
	});
	break;
	case "new":
	printIdentifier(expr['class'], output);
	break;
	case "isvoid":
	printExp(expr['e'], output);
	break;
	case "plus":
	printExp(expr['x'], output);
	printExp(expr['y'], output);
	break;
	case "minus":
	printExp(expr['x'], output);
	printExp(expr['y'], output);
	break;
	case "times":
	printExp(expr['x'], output);
	printExp(expr['y'], output);
	break;
	case "divide":
	printExp(expr['x'], output);
	printExp(expr['y'], output);
	break;
	case "lt":
	printExp(expr['x'], output);
	printExp(expr['y'], output);
	break;
	case "le":
	printExp(expr['x'], output);
	printExp(expr['y'], output);
	break;
	case "eq":
	printExp(expr['x'], output);
	printExp(expr['y'], output);
	break;
	case "not":
	printExp(expr['x'], output);
	break;
	case "negate":
	printExp(expr['x'], output);
	break;
	case "integer":
	output.write(expr['value'] + "\n");
	break;
	case "string":
	output.write(expr['value'] + "\n");
	break;
	case "identifier":
	printIdentifier(expr['variable'], output);
	break;
	case "true":
	break;
	case "false":
	break;
	case "case":
	printExp(expr['case'], output);
	output.write(expr['elements'].length + "\n");
	expr['elements'].forEach(function (elem) {
	    printIdentifier(elem['variable'], output);
	    printIdentifier(elem['type'], output);
	    printExp(elem['body'], output);
	});
	break;
	case "let":
	output.write(expr['bindings'].length + "\n");
	expr['bindings'].forEach(function (bind) {
	    output.write(bind['name'] + "\n");
	    printIdentifier(bind['variable'], output);
	    printIdentifier(bind['type'], output);
	    if (bind.hasOwnProperty('value')) {
		printExp(bind['value'], output);
	    }
	});
	printExp(expr['expr'], output);
	break;
    }
};

// Function call for final output
printProg(final_ast, output);
output.end();
